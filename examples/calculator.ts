
/**
 * Represents a slice of a text file.
 *
 * This object uses byte offsets to point to the right part of the text file.
 * If you want to move the range you will have to modify both the start and the
 * end offset.
 */
export class SourceTextSpan {

  constructor(
    public startOffset: number,
    public endOffset: number
  ) {

  }

  /**
   * Count how many characters there are in this slice.
   */
  public get size() {
    return this.endOffset - this.startOffset;
  }

}

// This acts as a global counter that is incremented each time we create a new
// node. That way, we can hash nodes based on their ID and be sure there are no
// collisions.
let nextNodeId = 0;

// This is a forward-declaration of a function that will be generated by
// tsastgen. tsastgen does not explicitly need these declarations. It is only
// useful if you're going to use a generated function in this file.
export declare function isDefinition(value: any): value is Definition;

// This is our root node. You specify it on the command-line with --root-node.
// If you forget to add this flag, tsastgen will by default search for a root
// node named 'Syntax'.
// Every node that should be part of the AST should in some way inherit from
// the root node. If you forget to do this, tsastgen will just emit the
// class/interface without any transformations.
export class CalcNode {

  public readonly id: number;

  constructor(
    public span: SourceTextSpan | null = null,
    public parentNode: CalcNode | null = null
  ) {
    this.id = nextNodeId++;
  }

}

/**
 * A sheet is just a text file with a named list of simple arithmetic expressions.
 *
 * Something like this:
 *
 * ```
 * foo = (x + 2) / (y - 1)
 *
 * bar = 42;
 * ```
 */
export class Sheet extends CalcNode {

  // This map is used to efficiently look up a definition given only is name.
  private definitionsByName = Object.create(null);

  constructor(
    public elements: SheetElement[],
    span: SourceTextSpan | null = null,
    parentNode: CalcNode | null = null,
  ) {
    super(span, parentNode);
    for (const element of elements) {
      if (isDefinition(element)) {
        this.definitionsByName[element.name.text] = element;
      }
    }
  }

  /**
   * Get a definition using its name and return nothing if it was not found.
   *
   * @param name The name of the definition to search for.
   */
  public getDefinition(name: string): Definition | null {
    return this.definitionsByName[name] ?? null;
  }

}

// All things that can be written inside a sheet should inherit from this node.
// In this example, this is just a Definition.
export interface SheetElement extends CalcNode {}

// This could be a token generated by a scanner/lexer.
export interface Identifier extends CalcNode {
  text: string;
}

export interface Definition extends SheetElement {
  name: Identifier;
  expression: Expression;
}

export class Expression extends CalcNode {

  constructor(
    public tag: string | null = null,
    span: SourceTextSpan | null = null,
    parentNode: CalcNode | null = null
  ) {
    super(span, parentNode);
  }

}

// Because a constant expression only contains one field, you will very
// frequently be able to swap createConstantExpression(x) with just x. tsastgen
// applies some magic to make this work with all factory functions.
export interface ConstantExpression extends Expression {
  value: number;
}

// Because this interfaces's string field does not overlap with
// ConstantExpression's value field, you will be able to use just strings or
// numbers when constructing a new Expression.
export interface ReferenceExpression extends Expression {
  name: string;
}

// You can view this as a kind of 'mixin' that will be pushed inside every node
// that inherits from it. Note that this interface does not extend CalcNode,
// though in theory it could.
export interface BinaryExpression {
  left: Expression;
  right: Expression;
}

// Finally, our nodes that are able to calculate something!

export interface SubtractExpression extends BinaryExpression, Expression {}
export interface AddExpression extends BinaryExpression, Expression {}
export interface MultiplyExpression extends BinaryExpression, Expression {}
export interface DivideExpression extends BinaryExpression, Expression {}

// This type alias only consists of references to other AST node types, so a
// predicate isCommutativeExpression will be generated after you have run
// tsastgen.
export type CommutativeExpression
  = AddExpression
  | SubtractExpression
  | MultiplyExpression;

